<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Object Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #444;
            background: #000;
            margin: 20px 0;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 10px;
            max-width: 600px;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: inline-block;
            width: 150px;
            margin-right: 10px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin: 10px;
            max-width: 600px;
        }
        
        .legend {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin: 10px;
            max-width: 600px;
        }
        
        .legend-item {
            display: inline-block;
            margin: 5px 15px;
        }
        
        .color-box {
            display: inline-block;
            width: 30px;
            height: 15px;
            margin-right: 8px;
            vertical-align: middle;
            border: 1px solid #666;
        }
    </style>
</head>
<body>
    <h1>4D Object Visualizer</h1>
    
    <div class="info">
        <p>This visualizes a <strong>tesseract (4D hypercube)</strong> by projecting it through 4D→3D→2D.</p>
        <p>Each dimension is color-coded to help visualize the 4D structure.</p>
    </div>
    
    <div class="legend">
        <h3>Edge Colors by Dimension:</h3>
        <div class="legend-item">
            <span class="color-box" style="background: #ff0000;"></span>
            <span>X-axis (Red)</span>
        </div>
        <div class="legend-item">
            <span class="color-box" style="background: #00ff00;"></span>
            <span>Y-axis (Green)</span>
        </div>
        <div class="legend-item">
            <span class="color-box" style="background: #0080ff;"></span>
            <span>Z-axis (Blue)</span>
        </div>
        <div class="legend-item">
            <span class="color-box" style="background: #ffff00;"></span>
            <span>W-axis (Yellow)</span>
        </div>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <h3>Rotation Controls</h3>
        
        <div class="control-group">
            <label>XY Rotation:</label>
            <input type="range" id="rotXY" min="0" max="628" value="0">
            <span id="rotXYVal">0°</span>
        </div>
        
        <div class="control-group">
            <label>XZ Rotation:</label>
            <input type="range" id="rotXZ" min="0" max="628" value="0">
            <span id="rotXZVal">0°</span>
        </div>
        
        <div class="control-group">
            <label>XW Rotation (4D):</label>
            <input type="range" id="rotXW" min="0" max="628" value="0">
            <span id="rotXWVal">0°</span>
        </div>
        
        <div class="control-group">
            <label>YW Rotation (4D):</label>
            <input type="range" id="rotYW" min="0" max="628" value="0">
            <span id="rotYWVal">0°</span>
        </div>
        
        <div class="control-group">
            <label>Distance from 4D:</label>
            <input type="range" id="distance4D" min="2" max="6" step="0.1" value="3">
            <span id="distanceVal">3</span>
        </div>
        
        <div class="control-group">
            <button onclick="animate()">Auto Rotate</button>
            <button onclick="stopAnimation()">Stop</button>
            <button onclick="resetRotation()">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let rotXY = 0, rotXZ = 0, rotXW = 0, rotYW = 0;
        let distance4D = 3;
        let animationId = null;
        
        // Color scheme for each dimension
        const colors = {
            x: '#ff0000',  // Red
            y: '#00ff00',  // Green
            z: '#0080ff',  // Blue
            w: '#ffff00'   // Yellow
        };
        
        // 4D Tesseract vertices (all combinations of ±1)
        function createTesseract() {
            const vertices = [];
            for (let x = -1; x <= 1; x += 2) {
                for (let y = -1; y <= 1; y += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        for (let w = -1; w <= 1; w += 2) {
                            vertices.push([x, y, z, w]);
                        }
                    }
                }
            }
            return vertices;
        }
        
        // Define edges connecting vertices with dimension information
        function createEdges() {
            const edges = [];
            const vertices = createTesseract();
            
            // Connect vertices that differ by exactly one coordinate
            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    let differences = 0;
                    let dimension = null;
                    
                    for (let k = 0; k < 4; k++) {
                        if (vertices[i][k] !== vertices[j][k]) {
                            differences++;
                            dimension = k; // Store which dimension differs
                        }
                    }
                    
                    if (differences === 1) {
                        // Map dimension index to axis name
                        const dimName = ['x', 'y', 'z', 'w'][dimension];
                        edges.push({
                            vertices: [i, j],
                            dimension: dimName,
                            color: colors[dimName]
                        });
                    }
                }
            }
            return edges;
        }
        
        const edges = createEdges();
        
        // 4D Rotation matrices
        function rotateXY(point, angle) {
            const [x, y, z, w] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [
                x * cos - y * sin,
                x * sin + y * cos,
                z,
                w
            ];
        }
        
        function rotateXZ(point, angle) {
            const [x, y, z, w] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [
                x * cos - z * sin,
                y,
                x * sin + z * cos,
                w
            ];
        }
        
        function rotateXW(point, angle) {
            const [x, y, z, w] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [
                x * cos - w * sin,
                y,
                z,
                x * sin + w * cos
            ];
        }
        
        function rotateYW(point, angle) {
            const [x, y, z, w] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [
                x,
                y * cos - w * sin,
                z,
                y * sin + w * cos
            ];
        }
        
        // Project from 4D to 3D (stereographic projection)
        function project4Dto3D(point, distance) {
            const [x, y, z, w] = point;
            const factor = distance / (distance - w);
            return [x * factor, y * factor, z * factor];
        }
        
        // Project from 3D to 2D (perspective projection)
        function project3Dto2D(point) {
            const [x, y, z] = point;
            const distance = 4;
            const factor = distance / (distance + z);
            const scale = 150;
            return [
                canvas.width / 2 + x * factor * scale,
                canvas.height / 2 - y * factor * scale,
                z // Return z for depth sorting
            ];
        }
        
        // Apply all rotations to a point
        function rotatePoint(point) {
            let p = point;
            p = rotateXY(p, rotXY);
            p = rotateXZ(p, rotXZ);
            p = rotateXW(p, rotXW);
            p = rotateYW(p, rotYW);
            return p;
        }
        
        // Main rendering function
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Transform vertices
            const vertices = createTesseract();
            const projected = vertices.map(v => {
                let p = rotatePoint(v);
                p = project4Dto3D(p, distance4D);
                return project3Dto2D(p);
            });
            
            // Calculate edge depths for sorting (painter's algorithm)
            const edgesWithDepth = edges.map(edge => {
                const [i, j] = edge.vertices;
                const z1 = projected[i][2];
                const z2 = projected[j][2];
                const avgDepth = (z1 + z2) / 2;
                return { ...edge, depth: avgDepth };
            });
            
            // Sort edges by depth (draw far edges first)
            edgesWithDepth.sort((a, b) => a.depth - b.depth);
            
            // Draw edges with dimension-based colors
            ctx.lineWidth = 2;
            
            edgesWithDepth.forEach(edge => {
                const [i, j] = edge.vertices;
                const [x1, y1] = projected[i];
                const [x2, y2] = projected[j];
                
                // Use opacity based on depth for better 3D effect
                const opacity = Math.min(1, Math.max(0.3, 1 - (edge.depth + 2) / 8));
                
                ctx.strokeStyle = edge.color;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });
            
            ctx.globalAlpha = 1;
            
            // Draw vertices
            projected.forEach(([x, y, z]) => {
                const size = 5 - z * 0.3; // Size varies with depth
                const opacity = Math.min(1, Math.max(0.4, 1 - (z + 2) / 8));
                
                ctx.globalAlpha = opacity;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, Math.max(2, size), 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.globalAlpha = 1;
        }
        
        // Control handlers
        document.getElementById('rotXY').addEventListener('input', (e) => {
            rotXY = e.target.value / 100;
            document.getElementById('rotXYVal').textContent = Math.round(rotXY * 180 / Math.PI) + '°';
            render();
        });
        
        document.getElementById('rotXZ').addEventListener('input', (e) => {
            rotXZ = e.target.value / 100;
            document.getElementById('rotXZVal').textContent = Math.round(rotXZ * 180 / Math.PI) + '°';
            render();
        });
        
        document.getElementById('rotXW').addEventListener('input', (e) => {
            rotXW = e.target.value / 100;
            document.getElementById('rotXWVal').textContent = Math.round(rotXW * 180 / Math.PI) + '°';
            render();
        });
        
        document.getElementById('rotYW').addEventListener('input', (e) => {
            rotYW = e.target.value / 100;
            document.getElementById('rotYWVal').textContent = Math.round(rotYW * 180 / Math.PI) + '°';
            render();
        });
        
        document.getElementById('distance4D').addEventListener('input', (e) => {
            distance4D = parseFloat(e.target.value);
            document.getElementById('distanceVal').textContent = distance4D.toFixed(1);
            render();
        });
        
        function animate() {
            stopAnimation();
            animationId = setInterval(() => {
                rotXW += 0.01;
                rotYW += 0.015;
                rotXY += 0.008;
                render();
            }, 30);
        }
        
        function stopAnimation() {
            if (animationId) {
                clearInterval(animationId);
                animationId = null;
            }
        }
        
        function resetRotation() {
            stopAnimation();
            rotXY = rotXZ = rotXW = rotYW = 0;
            document.getElementById('rotXY').value = 0;
            document.getElementById('rotXZ').value = 0;
            document.getElementById('rotXW').value = 0;
            document.getElementById('rotYW').value = 0;
            document.getElementById('rotXYVal').textContent = '0°';
            document.getElementById('rotXZVal').textContent = '0°';
            document.getElementById('rotXWVal').textContent = '0°';
            document.getElementById('rotYWVal').textContent = '0°';
            render();
        }
        
        // Initial render
        render();
    </script>
</body>
</html>